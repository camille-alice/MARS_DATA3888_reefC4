midpoint = (lower_interval + upper_interval)/2
calstat = sd(interval)
statSignal = rbind(statSignal, c(midpoint, calstat))
lower_interval = lower_interval + window_size
} ## end while
knitr::opts_chunk$set(echo = TRUE)
n = 1
p = n
while(p < 10000000)
{
p = p*n
n = n+1
}
p
n
n = 1
p = n
while(p < 10000000)
{
n = n+1
p = p*n
}
p
n
knitr::opts_knit$set(root.dir = '/Users/camillekarski/Documents/Uni/DATA3888')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggthemes)
library(tidyverse)
library(class)
library(cvTools)
library(ggplot2)
library(e1071)
library(glmnet)
library(tuneR)
library(GEOquery)
#reading in ONE file
waveSeq = readWave("./DATA3888_data/LRL_data/LRL_L1.wav")
# time (in second) of the sequencing
timeSeq = seq_len(length(waveSeq))/waveSeq@samp.rate
windowsize = 0.1 * waveSeq@samp.rate
testStat = rep(NA, length(timeSeq) - windowsize)
for (i in 1:(length(timeSeq) - windowsize)){
testStat[i] <- IQR(waveSeq@left[i:(i + windowsize)])
}
start = round(windowsize/2)
end = start + length(testStat) - 1
plot(timeSeq, waveSeq@left, type = "l", ylab="Signal",xlab="Time(seconds)")
lines(timeSeq[c(start:end)], testStat, col="red")
waveSeq@samp.rate
windowsize
#reading in ONE file
waveSeq = readWave("./DATA3888_data/LRL_data/LRL_L1.wav")
# time (in second) of the sequencing
timeSeq = seq_len(length(waveSeq))/waveSeq@samp.rate
windowsize = 0.1 * waveSeq@samp.rate
testStat = rep(NA, length(timeSeq) - windowsize)
for (i in 1:(length(timeSeq) - windowsize)){
testStat[i] <- IQR(waveSeq@left[i:(i + windowsize)])
}
start = round(windowsize/2)
end = start + length(testStat) - 1
plot(timeSeq, waveSeq@left, type = "l", ylab="Signal",xlab="Time(seconds)")
lines(timeSeq[c(start:end)], testStat, col="red")
window_size = waveSeq@samp.rate/10
Y = waveSeq@left
increment4 = window_size/10   # 1,000
statSignal = c(NA,NA)
lower_interval = 1
max_time = length(waveSeq)
# using a while loop for continuous data that can be extracted and calculated in real time
# a for loop is when you have data that you know has an end point
while(max_time > lower_interval + window_size)
{
upper_interval = lower_interval + window_size
interval = Y[lower_interval:upper_interval]
midpoint = (lower_interval + upper_interval)/2
calstat = IQR(interval)
statSignal = rbind(statSignal, c(midpoint, calstat))
lower_interval = lower_interval + window_size
} ## end while
#plotting
df_line = data.frame(timeSeq)
df_line$y = c(waveSeq@left)
df_point = data.frame("Midpoint" = statSignal[-1, 1]/waveSeq@samp.rate,
"StatCalc" = statSignal[-1, 2] )
colours = c("Streamed Signal" = "grey", "IQR" = "red")
ggplot() +
geom_line(data=df_line, aes(x=timeSeq, y=y, colour="Streamed Signal")) +
geom_point(data=df_point, aes(x=Midpoint, y=StatCalc, colour="IQR"), size=0.7) +
geom_line(data=df_point, aes(x=Midpoint, y=StatCalc, colour="IQR")) +
#geom_point(data = df_event, aes(x=value, y=y,colour="Event")) +
labs(title = "Statistical Signal\nIncrements of 1,000",x = "Time", y = "Signal",colour = "Legend") +
scale_color_manual(values = colours)
window_size = waveSeq@samp.rate/10
Y = waveSeq@left
increment4 = window_size   # 1,000
statSignal = c(NA,NA)
lower_interval = 1
max_time = length(waveSeq)
# using a while loop for continuous data that can be extracted and calculated in real time
# a for loop is when you have data that you know has an end point
while(max_time > lower_interval + window_size)
{
upper_interval = lower_interval + window_size
interval = Y[lower_interval:upper_interval]
midpoint = (lower_interval + upper_interval)/2
calstat = IQR(interval)
statSignal = rbind(statSignal, c(midpoint, calstat))
lower_interval = lower_interval + window_size
} ## end while
#plotting
df_line = data.frame(timeSeq)
df_line$y = c(waveSeq@left)
df_point = data.frame("Midpoint" = statSignal[-1, 1]/waveSeq@samp.rate,
"StatCalc" = statSignal[-1, 2] )
colours = c("Streamed Signal" = "grey", "IQR" = "red")
ggplot() +
geom_line(data=df_line, aes(x=timeSeq, y=y, colour="Streamed Signal")) +
geom_point(data=df_point, aes(x=Midpoint, y=StatCalc, colour="IQR"), size=0.7) +
geom_line(data=df_point, aes(x=Midpoint, y=StatCalc, colour="IQR")) +
#geom_point(data = df_event, aes(x=value, y=y,colour="Event")) +
labs(title = "Statistical Signal\nIncrements of 1,000",x = "Time", y = "Signal",colour = "Legend") +
scale_color_manual(values = colours)
window_size = waveSeq@samp.rate/10  # 1,000 = 0.1 seconds
Y = waveSeq@left
statSignal = c(NA,NA)
lower_interval = 1
max_time = length(waveSeq)
# using a while loop for continuous data that can be extracted and calculated in real time
# a for loop is when you have data that you know has an end point
while(max_time > lower_interval + window_size)
{
upper_interval = lower_interval + window_size
interval = Y[lower_interval:upper_interval]
midpoint = (lower_interval + upper_interval)/2
calstat = IQR(interval)
statSignal = rbind(statSignal, c(midpoint, calstat))
lower_interval = lower_interval + window_size
} ## end while
#plotting
df_line = data.frame(timeSeq)
df_line$y = c(waveSeq@left)
df_point = data.frame("Midpoint" = statSignal[-1, 1]/waveSeq@samp.rate,
"StatCalc" = statSignal[-1, 2] )
colours = c("Streamed Signal" = "grey", "IQR" = "red")
ggplot() +
geom_line(data=df_line, aes(x=timeSeq, y=y, colour="Streamed Signal")) +
geom_point(data=df_point, aes(x=Midpoint, y=StatCalc, colour="IQR"), size=0.7) +
geom_line(data=df_point, aes(x=Midpoint, y=StatCalc, colour="IQR")) +
#geom_point(data = df_event, aes(x=value, y=y,colour="Event")) +
labs(title = "Statistical Signal\nIncrements of 1,000",x = "Time", y = "Signal",colour = "Legend") +
scale_color_manual(values = colours)
## Answer
# reading in bio data
## import directly from the net
load("./DATA3888_data/GolubData.RData")
dim(golub)
#B-cell acute lymphoblastic leukemia (B-ALL)
#T-cell acute lymphoblastic leukemia (T-ALL)
#acute myeloid leukemia (AML)
resp = matrix(unlist(sapply(colnames(golub), strsplit, ":")), nrow=2)[1,]
## Answer (includig graphics)
resp = matrix(unlist(sapply(colnames(golub), strsplit, ":")), nrow=2)[1,]
varValue = apply(golub, 1, var, na.rm=TRUE)
cutoffvalue = sort(varValue, decreasing = TRUE)[150]
varid = which(varValue >= cutoffvalue)
X = as.matrix(t(golub[varid,]))
y = resp
n = length(y)
#repeated cv KNN
K = 7  # number of CV folds
nperm = 45
cvK = 7
cv_all = NA
for (i in 1:nperm)
{
cvSets = cvTools::cvFolds(n, cvK)
cv_acc = NA
for (j in 1:K)
{
test_id = cvSets$subsets[cvSets$which == j]
X_test = X[test_id, ]
X_train = X[-test_id, ]
y_test = y[test_id]
y_train = y[-test_id]
fit = class::knn(train = X_train, test=X_test, cl=y_train, k=5)
cv_acc[j] = mean(fit == y_test)
}
cv_all[i] = mean(cv_acc)
}
cv_all
boxplot(cv_acc5_rtimes)
boxplot(cv_acc5_rtimes)
boxplot(cv_all)
#visualization for repeated cv KNN
cv_df = data.frame(Iteration=c(1:45),Mean_val=cv_all)
# Basic box plot w/ violin
cv_vis <- ggplot(cv_df, aes(x="Frequency",y=Mean_val)) +
geom_violin(width=0.7, fill = "#196c8a",color="#196c8a", alpha=0.7) +
geom_boxplot(width=0.45, color="grey", alpha=0.2,
outlier.colour="red",
outlier.fill="red",
outlier.size=3) +
labs(title = "Cross Validation Estimates",
x = "",
y = "Mean Accuracy") +
coord_flip()
cv_vis
#visualization for repeated cv KNN
cv_df = data.frame(Iteration=c(1:45),Mean_val=cv_all)
# Basic box plot w/ violin
cv_vis <- ggplot(cv_df, aes(x="Frequency",y=Mean_val)) +
geom_violin(width=0.7, fill = "#196c8a",color="#196c8a", alpha=0.7) +
geom_boxplot(width=0.45, color="grey", alpha=0.2,
outlier.colour="red",
outlier.fill="red",
outlier.size=3) +
labs(title = "Cross Validation Estimates w/ K=7",
x = "",
y = "Mean Accuracy") +
coord_flip()
cv_vis
#visualization for repeated cv KNN
cv_df = data.frame(Iteration=c(1:45),Mean_val=cv_all)
# Basic box plot w/ violin
cv_vis <- ggplot(cv_df, aes(x="Frequency",y=Mean_val)) +
geom_violin(width=0.7, fill = "#196c8a",color="#196c8a", alpha=0.7) +
geom_boxplot(width=0.45, color="grey", alpha=0.2,
outlier.colour="red",
outlier.fill="red",
outlier.size=3) +
labs(title = "Cross Validation Estimates\n K=7",
x = "",
y = "Mean Accuracy") +
coord_flip()
cv_vis
#visualization for repeated cv KNN
cv_df = data.frame(Iteration=c(1:45),Mean_val=cv_all)
# Basic box plot w/ violin
cv_vis <- ggplot(cv_df, aes(x="Frequency",y=Mean_val)) +
geom_violin(width=0.7, fill = "#196c8a",color="#196c8a", alpha=0.7) +
geom_boxplot(width=0.45, color="grey", alpha=0.2,
outlier.colour="red",
outlier.fill="red",
outlier.size=3) +
labs(title = "Cross Validation Estimates\nK=7",
x = "",
y = "Mean Accuracy") +
coord_flip()
cv_vis
## Answer (including graphics)
nperm = 1
cvK = 5 # number of CV folds
cv_all_1 = NA
for (i in 1:nperm)
{
cvSets = cvTools::cvFolds(n, cvK)
cv_acc = NA
for (j in 1:cvK)
{
test_id = cvSets$subsets[cvSets$which == j]
X_test = X[test_id, ]
X_train = X[-test_id, ]
y_test = y[test_id]
y_train = y[-test_id]
fit = class::knn(train = X_train, test=X_test, cl=y_train, k=10)
cv_acc[j] = mean(fit == y_test)
}
cv_all_1[i] = mean(cv_acc)
}
table(knn5, y_test)
#cross validation
pima = read_csv('./DATA3888_data/pima.csv')
pima_scaled = pima %>% mutate(y = factor(y)) %>% mutate_if(is.numeric, .funs = scale) #ensuring not predicting as int
X = pima_scaled %>% select(-y) %>% scale() #scaling
y = pima_scaled %>% select(y) %>% pull()
n = length(y)
## Selection 25% of the data as test set
test_id = sample(1:nrow(pima), round(nrow(pima)*0.25))
X_test = X[test_id, ]
X_train = X[-test_id, ]
y_test = y[test_id]
y_train = y[-test_id]
## train and test with knn
knn5 = class::knn(train = X_train, test = X_test, cl = y_train, k = 5)
table(knn5, y_test)
#accuracy
mean(knn5 == y_test) %>% round(2)
## Answer (including graphics)
nperm = 1
cvK = 5 # number of CV folds
cv_all_1 = NA
for (i in 1:nperm)
{
cvSets = cvTools::cvFolds(n, cvK)
cv_acc = NA
for (j in 1:cvK)
{
test_id = cvSets$subsets[cvSets$which == j]
X_test = X[test_id, ]
X_train = X[-test_id, ]
y_test = y[test_id]
y_train = y[-test_id]
fit = class::knn(train = X_train, test=X_test, cl=y_train, k=10)
cv_acc[j] = mean(fit == y_test)
}
cv_all_1[i] = mean(cv_acc)
}
table(fit, y_test)
## Answer (including graphics)
cvK = 5 # number of CV folds
cvSets = cvTools::cvFolds(n, cvK)
fitres = factor()
true_y = c()
for (j in 1:cvK){
test_id = cvSets$subsets[cvSets$which == j]
X_test = X[test_id, ]
X_train = X[-test_id, ]
y_test = y[test_id]
y_train = y[-test_id]
fit = class::knn(train = X_train, test=X_test, cl=y_train, k=10)
fitres = c(fitres, as.vector(fit5))
true_y = c(true_y, y_test)
}
## Answer (including graphics)
cvK = 5 # number of CV folds
cvSets = cvTools::cvFolds(n, cvK)
fitres = factor()
true_y = c()
for (j in 1:cvK){
test_id = cvSets$subsets[cvSets$which == j]
X_test = X[test_id, ]
X_train = X[-test_id, ]
y_test = y[test_id]
y_train = y[-test_id]
fit = class::knn(train = X_train, test=X_test, cl=y_train, k=10)
fitres = c(fitres, as.vector(fit))
true_y = c(true_y, y_test)
}
ctab = table(fitres, true_y)
ctab
## Answer (including graphics)
X = t(golub[varid,])
y = resp
n = nrow(X)
cvK = 5 # number of CV folds
cvSets = cvTools::cvFolds(n, cvK)
fitres = factor()
true_y = c()
for (j in 1:cvK){
test_id = cvSets$subsets[cvSets$which == j]
X_test = X[test_id, ]
X_train = X[-test_id, ]
y_test = y[test_id]
y_train = y[-test_id]
fit = class::knn(train = X_train, test=X_test, cl=y_train, k=10)
fitres = c(fitres, as.vector(fit))
true_y = c(true_y, y_test)
}
ctab = table(fitres, true_y)
ctab
fitres
true_y
## Answer (including graphics)
X = t(golub[varid,])
y = resp
n = nrow(X)
cvK = 5 # number of CV folds
cvSets = cvTools::cvFolds(n, cvK)
fitres = factor()
true_y = c()
for (j in 1:cvK){
test_id = cvSets$subsets[cvSets$which == j]
X_test = X[test_id, ]
X_train = X[-test_id, ]
y_test = y[test_id]
y_train = y[-test_id]
fit = class::knn(train = X_train, test=X_test, cl=y_train, k=10)
fitres = c(fitres, as.vector(fit))
true_y = c(true_y, y_test)
}
ctab = table(fitres, true_y)
ctab
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/Users/camillekarski/Documents/Uni/DATA3888')
library(plyr)
library(tidyverse)
library(tuneR)
library(devtools)
library(ggplot2)
library(tsfeatures)
library(sf)
library(maps)
library(reshape2)
library(viridis)
library(plotly)
library(GGally)
#function for extracting features from zipped archives
reef_f_extract = function(file_path,zip_name,feature_path,out_dir, reef_df){
file_ls = as.character(unzip(paste0(file_path,zip_name), list = TRUE)$Name)
feature_filename = str_subset(file_ls, feature_path)
if (length(feature_filename) != 0){
unzip(paste0(file_path,zip_name), files=feature_filename, exdir = out_dir)
rugosity_df = st_read(paste0(out_dir, feature_filename))
sf_use_s2(FALSE)
reef_join_df = st_join(reef_df, rugosity_df)
}#end if
return(reef_join_df)
} #end function
#reading in reef data set ! with variables
reef_df =st_read("./DATA3888_data/Reef_Check_with_cortad_variables_with_annual_rate_of_SST_change.csv",
options=c("X_POSSIBLE_NAMES=Longitude.Degrees","Y_POSSIBLE_NAMES=Latitude.Degrees"))
#reading in reef data set ! with variables
reef_df =st_read("./DATA3888_data/Reef_Check_with_cortad_variables_with_annual_rate_of_SST_change.csv",
options=c("X_POSSIBLE_NAMES=Longitude.Degrees","Y_POSSIBLE_NAMES=Latitude.Degrees"))
#setting reef_df to same CRS
st_crs(reef_df) = 4326
# file name containing all data: Global-Dataset-20211006223100
file_path = "./DATA3888_data/Global-Dataset-20211006223100.nosync/"
geom_filepath = "^Geomorphic-Map/geomorphic"
test_i = "Andaman-Sea-20201117212207.zip"
test_dir = "./DATA3888_data/geomorphic_test/"
reef_join_test = reef_df
reef_join_test = reef_f_extract(file_path,test_i,geom_filepath,test_dir,reef_join_test)
test_r = "Bermuda-20210611214055.zip"
reef_join_test = reef_f_extract(file_path,test_r,geom_filepath,test_dir,reef_join_test)
reef_join_test
# file name containing all data: Global-Dataset-20211006223100
file_path = "./DATA3888_data/Global-Dataset-20211006223100.nosync/"
#creating list of all files in folder
files = list.files(path=file_path, pattern=".zip$", recursive = F)
#setting new directory for where data will go
outDir = "./DATA3888_data/geomorphic_all/"
#target file name for extraction
geom_filepath = "^Geomorphic-Map/geomorphic"
reef_join_df = reef_df
#commented out so as not to run again
for (i in files) {
reef_join_df = reef_f_extract(file_path,i,geom_filepath,outDir,reef_join_df)
}
reef_join_df
#write to gpkg - Reading layer `Great Barrier Reef and Torres Strait' from data source
#st_write(reef_join_df, 'reef_geomorphic_joined.gpkg')
classes = c(class.x, class.y, class.x.1, class.y.1, class.x.2, class.y.2, class.x.3, class.y.3, class.x.4, class.y.4, class.x.5, class.y.5, class.x.6, class.y.6)
classes = c('class.x', 'class.y', 'class.x.1', 'class.y.1', 'class.x.2', 'class.y.2', 'class.x.3', 'class.y.3', 'class.x.4', 'class.y.4', 'class.x.5', 'class.y.5', 'class.x.6', 'class.y.6')
reef_join_c = reef_join_df %>% mutate(class = coalesce(classes)) %>%
select(classes)
classes = c('class.x', 'class.y', 'class.x.1', 'class.y.1', 'class.x.2', 'class.y.2', 'class.x.3', 'class.y.3', 'class.x.4', 'class.y.4', 'class.x.5', 'class.y.5', 'class.x.6', 'class.y.6')
reef_join_c = reef_join_df %>% mutate(class = coalesce(classes)) %>%
select(-classes)
#classes = c(class.x, class.y, class.x.1, class.y.1, class.x.2, class.y.2, class.x.3, class.y.3, class.x.4, class.y.4, class.x.5, class.y.5, class.x.6, class.y.6)
reef_join_c = reef_join_df %>% mutate(class = coalesce(class.x, class.y, class.x.1, class.y.1, class.x.2, class.y.2, class.x.3, class.y.3, class.x.4, class.y.4, class.x.5, class.y.5, class.x.6, class.y.6)) %>%
select(-class.x, -class.y, -class.x.1, -class.y.1, -class.x.2, -class.y.2, -class.x.3, -class.y.3, -class.x.4, -class.y.4, -class.x.5, -class.y.5, -class.x.6, -class.y.6)
#write to gpkg - Reading layer `Great Barrier Reef and Torres Strait' from data source
#st_write(reef_join_df, 'reef_geomorphic_joined.gpkg')
reef_join_c
reef_join_c_NA = reef_join_c %>% drop_na()
world_map = map_data("world")
ggplot() +
geom_polygon(data =world_map, aes(x=long, y = lat, group = group), fill="grey", alpha=0.3) +
geom_sf(data = reef_join_c_NA, aes(colour = class), alpha=0.6) +
#geom_sf(data = rugosity_df_small, aes(colour = class)) + #commented out as dataset is too large
theme_void()
#write to gpkg - Reading layer `Great Barrier Reef and Torres Strait' from data source
st_write(reef_join_c, 'reef_geomorphic_joined.gpkg')
reef_join_c_NA
shiny::runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
shiny::runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
runApp('Documents/Uni/DATA3888/Test_reef copy')
shiny::runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
runApp('Documents/Uni/DATA3888/Test_reef')
shiny::runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
shiny::runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp()
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
runApp('Documents/Uni/DATA3888/DATA3888_GitHub/MARS_DATA3888_reefC4/app_reef')
